<?php

/*
 * задание номер 2 - перемножение длинных чисел
 */


class LongMultiplier {

    // получить промежуточные длинные слагаемые при умножении
    protected function getOperandsForSum($filename, $tailOffset)
    {
        // считать операнды из файла для суммирования
        $operands = explode('#', file_get_contents($filename));
        $n1 = trim($operands[0]);
        $n2 = trim($operands[1]);

        // на первом цикле первый операнд пустой
        if (empty($n1)) {
            return [0, $n2, ''];
        }

        // сдвинуть (при сложении столбиком) первый верхний операнд вправо на один разряд и хвост сохранить
        // (при сложении столбиком первое слагаемое сдвигается вправо, вернее второе слагамое - влево)
        $tail = substr($n1, $tailOffset);

        // оставшаяся передняя часть числа будет слагаемым
        $n1 = substr($n1, 0, $tailOffset);

        // в случае чисел в один разряд
        if (empty($n1)) {
           $n1 = '0';
        }

        $len1 = strlen($n1);
        $len2 = strlen($n2);

        // заполнить у меньшего числа старшие разряды нулями до выравнивания по длине с большим
        // (для сложения чисел столбиком)
        if ($len1 < $len2) {
            for ($i = 1; $i <= $len2 - $len1; $i++) {
                $n1 = "0" . $n1;
            }
        } else {
            for ($i = 1; $i <= $len1 - $len2; $i++) {
                $n2 = "0" . $n2;
            }
        }

        // передаю слагаемые в метод сложения, и хвост (младший разряд первого слагаемого) чтобы приставить в конце
        return [$n1, $n2, $tail];
    }

    // сложение промежуточных длинных слагаемых при умножении
    public function calcTempSum($filename, $tailOffset)
    {
        list($n1, $n2, $tail) = $this->getOperandsForSum($filename, $tailOffset);

        // на первом цикле первый операнд пустой
        if ((empty($n1)) and ($tailOffset == 0)) {
            file_put_contents ($filename, $n2);
            return;
        }

        $sum = '';
        $stack = new SplStack();
        $stack->push(0);

        // складываю справа налево (без реверса), начиная с младших разрядов
        for ($i = strlen($n1) - 1; $i >= 0; $i--) {
            // вытаскиваю старший образовавшийся разряд с предыдущего цикла
            $upper = $stack->pop();
            // сложить разряды и добавить старший разряд с предыдущего цикла
            $temp = $n1[$i] + $n2[$i] + $upper;

            if ($temp >= 10) {
                // если при сложении появился старший разряд, то в стек его
                $stack->push(1);
                $temp = $temp - 10;
            } else {
                // если не появился, значит он равен нулю
                $stack->push(0);
            }

            // добавляю цифры впереди
            $sum = $temp . $sum;
        }

        // на выходе из цикла если есть сташий разряд - то добавить впереди
        $upper = $stack->pop();
        if ($upper > 0) {
            $sum = $upper . $sum;
        }

        // на выходе из цикла добавить хвост в конце числа (младший разряд первого слагаемого)
        $sum .= $tail;

        // перезаписать файл результатом сложения,
        // на следующем цикле туда добавится следующее длинное слагаемое
        file_put_contents ($filename, $sum);
    }


    // получить операнды для умножения
    protected function getOperandsForMultiple($filename)
    {
        $operands = explode('#', file_get_contents($filename));
        $n1 = trim($operands[0]);
        $n2 = trim($operands[1]);

        return [$n1, $n2];
    }


    // метод умножения
    public function calcMultiple($filename = 'multiplication.txt')
    {
        // обнулить промежуточный файл при входе
        file_put_contents('tempsum.txt', '');

        list($n1, $n2) = $this->getOperandsForMultiple($filename);

        $stack = new SplStack();
        // на первом цикле первого слагаемого нет, поэтому не буду младший разряд (хвост) у него отделять
        $tailOffset = 1;

        // во внешнем цикле беру разряд второго операнда и перемножаю на все разряды первого во внутреннем цикле
        for ($i = strlen($n2) - 1; $i >=0; $i--) {

            $result = '';
            // с каждым циклом смещение для отделения младшего разряда (хвоста) у первого слагаемого увеличивается (в обратную сторону)
            $tailOffset--;
            $stack->push(0);

            // внутр цикл, где перемножаю разряд второго операнда на все разряды первого
            for ($j = strlen($n1) - 1; $j >= 0; $j--) {
                // старший разряд с предыдущего цикла
                $upper = $stack->pop();

                // перемножаю разряды, добавляю старший разряд с предыдущего цикла
                $temp = $n1[$j] * $n2[$i] + $upper;

                if ($temp >= 10) {
                    // если образовался старший разряд, то в стек его
                    $temp .= '';
                    $newupper = $temp[0] + 0;
                    $stack->push($newupper);
                    // оставляю только младший разряд для конкатенации
                    $temp = $temp[1] + 0;
                } else {
                    // если не появился старший, то 0 для баланса
                    $stack->push(0);
                }

                // добавляю разряды впереди числа
                $result = $temp . $result;
            }

            // на выходе если остался старший разряд, то добавить его
            $upper = $stack->pop();
            if ($upper > 0) {
                $result = "#" . $upper . $result;
            } else {
                $result = "#" . $result;
            }

            // новое слагаемое готово, добавить его в файл к слагаемому с предыдущего цикла
            file_put_contents('tempsum.txt', $result, FILE_APPEND | LOCK_EX);

            // сложить их в этом методе,
            // и передам смещение для отделения младших разрядов (хвоста) у предыдущего слагаемого,
            // смещение увеличивается на 1 с каждым циклом
            $this->calcTempSum('tempsum.txt', $tailOffset);
        }

        // когда все циклы закочились, в промежуточном файле будет результат, вывести его
        echo file_get_contents('tempsum.txt');
    }
}


$math = new LongMultiplier();
$math->calcMultiple();